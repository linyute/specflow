---
title: "模式與最佳實踐"
description: "AI 編程社群萃取的智慧結晶"
---

[← 返回 Reddit 智慧結晶](../index.html){.back-link}

## agent-first 開發的核心模式

分析 47 篇貼文與數千名開發者經驗後，明確模式浮現，區分了成功的 AI 協作開發與令人沮喪的失敗。這些模式經集體實驗發現，成為高效 agent-first 工作流程的基礎。

## 成功的四大支柱

### 1. 上下文架構
**模式**：成功開發者將上下文視為基礎設施，而非事後補充。

:::{.pattern-card}
#### 上下文金字塔

```{mermaid}
flowchart TB
    subgraph "策略性上下文"
        A[專案願景與目標]
        A1[商業需求]
        A2[成功指標]
        A --> A1
        A --> A2
    end
    
    subgraph "系統上下文"
        B[架構與設計]
        B1[技術棧決策]
        B2[API 合約]
        B3[資料庫結構]
        B --> B1
        B --> B2
        B --> B3
    end
    
    subgraph "模組上下文"
        C[元件摘要]
        C1[ai_module_summary.md]
        C2[相依關係圖]
        C3[測試覆蓋率]
        C --> C1
        C --> C2
        C --> C3
    end
    
    subgraph "任務上下文"
        D[目前工作計畫]
        D1[任務目標]
        D2[驗收標準]
        D3[邊界案例]
        D --> D1
        D --> D2
        D --> D3
    end
    
    subgraph "程式碼上下文"
        E[實作細節]
        E1[類似範例]
        E2[.cursorrules]
        E3[近期變更]
        E --> E1
        E --> E2
        E --> E3
    end
    
    A -.->|引導| B
    B -.->|指導| C
    C -.->|塑造| D
    D -.->|導向| E
    
    style A fill:#e3f2fd
    style B fill:#bbdefb
    style C fill:#90caf9
    style D fill:#64b5f6
    style E fill:#42a5f5
    
    style A1 fill:#e3f2fd
    style A2 fill:#e3f2fd
    style B1 fill:#bbdefb
    style B2 fill:#bbdefb
    style B3 fill:#bbdefb
    style C1 fill:#90caf9
    style C2 fill:#90caf9
    style C3 fill:#90caf9
    style D1 fill:#64b5f6
    style D2 fill:#64b5f6
    style D3 fill:#64b5f6
    style E1 fill:#42a5f5
    style E2 fill:#42a5f5
    style E3 fill:#42a5f5
```

**實作方式**：

- **專案層級**：維持清晰的 README 與架構文件
- **模組層級**：每個元件建立 `ai_module_summary.md`
- **任務層級**：用詳細工作計畫保留決策脈絡
- **程式碼層級**：參考現有類似程式碼作為範例
:::

### 2. 任務分解
**模式**：將複雜功能拆解為原子、可驗證步驟。

:::{.callout-tip}
**Goldilocks 原則**：任務要「剛剛好」——太大 AI 會失焦，太小則管理成本高於價值。

**理想任務大小**：15-30 分鐘實作時間
:::

良好範圍任務範例：

- ✅「在註冊表單加入 email 驗證」
- ✅「建立可重用的按鈕元件並加上 hover 狀態」
- ❌「建構整個認證系統」
- ❌「修正所有 bug」

### 3. 漸進式增強
**模式**：先有可執行骨架，再逐步加入功能。

```{mermaid}
flowchart LR
    subgraph "1. 基礎"
        A[基本結構]
        A1[檔案設置]
        A2[型別定義]
        A3[最小 UI]
    end
    
    subgraph "2. 核心"
        B[核心功能]
        B1[主流程]
        B2[基本測試]
        B3[API 整合]
    end
    
    subgraph "3. 強化"
        C[邊界案例]
        C1[錯誤處理]
        C2[驗證]
        C3[載入狀態]
    end
    
    subgraph "4. 優化"
        D[效能]
        D1[快取]
        D2[延遲載入]
        D3[檔案大小]
    end
    
    subgraph "5. 精緻化"
        E[細部修飾]
        E1[動畫]
        E2[無障礙]
        E3[文件]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    
    A --> A1
    A --> A2
    A --> A3
    
    B --> B1
    B --> B2
    B --> B3
    
    C --> C1
    C --> C2
    C --> C3
    
    D --> D1
    D --> D2
    D --> D3
    
    E --> E1
    E --> E2
    E --> E3
    
    style A fill:#e8f5e9
    style B fill:#c8e6c9
    style C fill:#a5d6a7
    style D fill:#81c784
    style E fill:#66bb6a
    
    style A1 fill:#f1f8e9
    style A2 fill:#f1f8e9
    style A3 fill:#f1f8e9
    
    style B1 fill:#dcedc8
    style B2 fill:#dcedc8
    style B3 fill:#dcedc8
    
    style C1 fill:#c5e1a5
    style C2 fill:#c5e1a5
    style C3 fill:#c5e1a5
    
    style D1 fill:#aed581
    style D2 fill:#aed581
    style D3 fill:#aed581
    
    style E1 fill:#9ccc65
    style E2 fill:#9ccc65
    style E3 fill:#9ccc65
```

此做法：

- 立即獲得回饋
- 維持可執行狀態
- 方便修正方向
- 讓 AI 理解逐步累積

### 4. 明確限制
**模式**：明確告訴 AI 不能做什麼，和要做什麼一樣重要。

常見限制模式：

```markdown
## 本任務限制：
- 不得修改任何現有測試
- 不得更動資料庫結構
- 不得重構無關程式碼
- 只限於上述檔案
- 保留所有現有功能
```

## 各專案階段的工作流程模式

### 新專案啟動

:::{.workflow-box}
**「願景優先」模式**

1. **定義最終狀態**：先寫用戶故事與成功標準
2. **設計介面**：先用 AI 產生 mockup/線框
3. **規劃架構**：讓 AI 根據需求建議結構
4. **垂直實作**：一次建構完整功能切片
:::

### 與現有程式碼庫協作

:::{.workflow-box}
**「考古挖掘」模式**

1. **繪製地圖**：請 AI 分析並記錄現有結構
2. **建立灘頭堡**：先做獨立、低風險變更
3. **建立理解**：為現有功能建立測試
4. **逐步擴展**：從已理解區域向外推進
:::

### 除錯與問題排查

:::{.workflow-box}
**「法醫分析」模式**

1. **先重現問題**：一定要有失敗測試案例
2. **隔離問題**：用二分法找出程式碼變更
3. **假設並測試**：讓 AI 提出可能原因
4. **驗證修正**：確保不影響其他功能
:::

## 需避免的反模式

### 1. 「魔法提示」迷思
❌ **反模式**：相信一個完美提示能產生整個應用

✅ **更好做法**：用明確檢查點反覆細化

### 2. 上下文超載
❌ **反模式**：將整個程式碼庫丟給 AI

✅ **更好做法**：針對每個任務精選相關上下文

### 3. 「唯唯諾諾」陷阱
❌ **反模式**：不經審查就接受 AI 建議

✅ **更好做法**：保持質疑，檢查所有變更

### 4. 範疇蔓延
❌ **反模式**：讓 AI「優化」超出指定任務的程式碼

✅ **更好做法**：用明確限制與聚焦提示

## 進階模式

### 多 agent 協作

社群發現不同 AI 模型擅長不同任務：

:::{.agent-roles}
| agent 角色 | 最適任務 | 範例模型 |
|------------|----------|----------------|
| **架構師** | 高階規劃、系統設計 | Claude 3.5、GPT-4 |
| **開發者** | 實作、程式撰寫 | Cursor Tab、Copilot |
| **審查者** | 安全分析、程式碼審查 | 專用模型 |
| **文件者** | 文件撰寫、註解 | GPT-3.5、Claude Instant |
:::

### 上下文保留策略

**模式**：「記憶宮殿」做法

1. **階層式文件**
   ```
   project-root/
   ├── AI_CONTEXT.md          # 專案總覽
   ├── docs/
   │   ├── architecture.md    # 系統設計
   │   └── decisions.md       # ADRs
   └── src/
       ├── module1/
       │   └── AI_SUMMARY.md  # 模組上下文
       └── module2/
           └── AI_SUMMARY.md  # 模組上下文
   ```

2. **Git 錨定上下文**

   - 標記重要里程碑
   - 在工作計畫引用 commit
   - 用分支做 AI 實驗

3. **session 交接**

   - 切換 AI session 時建立交接文件
   - 包含：目前狀態、近期變更、下一步
   - 引用特定檔案版本

## 成功指標

社群已找出健康 AI 協作開發的關鍵指標：

### 速度指標

- **任務完成率**：AI 嘗試 80% 以上應一次成功
- **迭代次數**：每功能平均 1-3 次
- **上下文切換**：相關工作批次處理以減少切換

### 品質指標

- **測試覆蓋率**：AI 產生程式碼應包含測試
- **審查變更**：AI 程式碼需大幅修正比例 <20%
- **bug 引入率**：應低於人工撰寫

### 流程指標

- **上下文準備時間**：佔總開發時間 10-20%
- **提示細化**：2-3 次即可達理想產出
- **文件比例**：文件/程式碼約 1:4

## 未來路徑

社群發現的模式指向未來：

1. **上下文成為可程式化基礎設施**
2. **AI agent 分工協作如人類團隊**
3. **開發流程能動態適應專案需求**
4. **品質來自流程，而非僅靠審查**

這些模式不只是優化——而是軟體開發思維的根本轉變。擁抱這些實踐，開發者能達到社群所稱「大規模心流」——在複雜專案中維持高生產力。

---

*這些模式來自社群在 AI 協作開發中 466.7% 成長的分析。[探索原始洞察 →](../insights/index.html)*

<style>
.pattern-card {
  background: var(--bs-light);
  padding: 1.5rem;
  border-radius: 0.5rem;
  margin: 1.5rem 0;
  border: 1px solid var(--bs-border-color);
}

.workflow-box {
  background: #f8f9fa;
  border-left: 4px solid var(--bs-primary);
  padding: 1rem 1.5rem;
  margin: 1.5rem 0;
}

.agent-roles {
  margin: 1.5rem 0;
}

.agent-roles table {
  width: 100%;
  background: white;
  border-radius: 0.5rem;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.agent-roles th {
  background: var(--bs-primary);
  color: white;
  padding: 0.75rem;
  text-align: left;
}

.agent-roles td {
  padding: 0.75rem;
  border-bottom: 1px solid var(--bs-border-color);
}

.agent-roles tr:last-child td {
  border-bottom: none;
}
</style>

---

**免責聲明**：本文件由 [GitHub Copilot](https://docs.github.com/copilot/about-github-copilot/what-is-github-copilot) 在本地化過程中產生，因此可能包含錯誤。如發現任何不當或錯誤翻譯，請至[問題頁面](../../issues)回報。